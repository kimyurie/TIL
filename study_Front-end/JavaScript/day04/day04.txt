배열 내장함수 (기본)

  lenght 

  push
  pop
  shift
  unshif
  splice
  slice
  concat
  indexOf
  join
  includes
  le

  sort [o]
  reverse [o]

  ------------------------------------------------------------------------------------------------

배열 고차함수 (중요 , JS)
    고차함수는 함수를 인자로 전달받거나, 함수를 결과로 반환하는 함수를 말한다.


    sort (()=>{ ... 실행문 })
    sort (function(){ ... 실행문 })

    function compare(a, b){
        ... if(a>b) rreturn 1
    }
    // 재사용을 하기위해서

    sort(compare)
    콜백함수 = 인자로서 함수가 들어가고 부모가 되는 함수가 해당 함수를 실행하는 경우

  ------------------------------------------------------------------------------------------------

    map
        배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수의 반환값으로 *새로운 배열* 을 생성
        경우에 따라 for문을 대체할수 있음

    filter
        경우에 따라 if문을 대체할 수 있으며 배열을 순회하며 각 요소에대하여 인자(매개변수, 파라미터)로
        주어진 콜백함수의 *실행결과가 true* 인 요소만 추출하여 *새로운 배열* 을 만든다

    find
        배열을 순회하며 인자로 주어진 콜백함수를 실행하고 그 결과가 참인 것 중 첫번째 요소를 *반환한다*

    findIndex
        find와의 기능은 같지만 해당 요소의 인덱스를 *반환한다*

    reduce
        누적 값을 구할 때 많이 사용
        요소들이 계산된 누적값과 현재 요소 변수를 return
        따라서 누적 값에 현재 요소를 더하면 ===> 전체 배열의 누적 값을 구할 수 있음

  ------------------------------------------------------------------------------------------------

    이터러블한 오브젝트
        - 순회 가능한 객체
        - 반복 가능한 객체
        

    이터러블 오브젝트 반복문
        1. forEach
        2. for in
        3. for of

    배열의 생성
        Array.from
        Array.fill

  ------------------------------------------------------------------------------------------------

    브라우저 랜더링 과정
        1. 면접 출현 질문 부동의 1위
        2. google.com을 주소창에 입력했을 시 벌어지는 일
        3. 본래의 주소는 ip주소로 이루어져있음
        4. 브라우저 엔진은 현재 내 브라우저에 똑같은 주소로 캐싱 되어있는 페이지 확인
        5. 만약에 페이지가 없으면, 해당 도메인에 해당 페이지를 랜더링(그리는)할 때 필요한 리소스(자원)
        ex) html, css, js, img ...
        6. 도메인은 DNS(도메인 네임 서버)를 통해 실제 ip주소에 요청을 전송
        7. 해당 리소스를 브라우저 엔진이 전달받음 -> 렌더링 엔진 -> 통신 레이어
        8. 렌더링 엔진은 해당하는 html, css, js를 받으면 html과 css를 트리 형식으로 변환
        9. html은 DOM tree, css는 CSS OM, js의 경우에는 자바스크립트 엔진(v8) ->  실행 (dom을 변화)
        10. 엔진이 이해할 수 있는 바이트 문자로 변환 -> 토큰화 -> 노드 -> 트리 -> node tree
        11. js로 인하여 변화된 DOM tree, css tree가 합쳐진 랜더링 트리(화면에 보여질 트리)
            dsiplay:none --> 실제 요소에 적용이 안되는 이유
        
        12. 렌더링 엔진을 렌더링 트리를 전달받고 렌더링 트리를 화면에 그리기 위해 파싱 작업
        13. 레이아웃 
                뷰포트 기준 랜더링 트리의 요소들의 그려질 크기와 위치를 계산하는 단계
                특정 이벤트에 의해 레이아웃 변경된다면 이 과정을 다시 진행하며
                다시 진행하는 과정을 reflow라고 한다. 단, reflow 시에는 repaint 과정을 무조건
                실행한다.

        14. 페인트 
                화면에 그리는 것, 스타일이 복잡할 수록 시간이 오래 걸린다.
                만약에 특정 이벤트에 의해 스타일이 변경된다면 처음부터 다시 화면을 그리는
                repaint를 실행

  ------------------------------------------------------------------------------------------------

   과제

    사이트 하나를 선정 (상품목록, 게시글목록, 상품상세, 게시글상세...)
    백엔드에게 받아올 데이터를 오브젝트로 만들어보는 것


    const prouductDetail = {
        name:
        content:
        price:
        main_img: "http..."
        sub_img: []
        ....
        ...
        review: []
    }

    만약에 상품 목록들이라고 하면 []로 받곘지만 객체 한 두개정도
    그리고 해당 데이터를 이용하여 map, filter, find, findIndex 등을 활용

    해당 과제를 통해서
    프론트엔드에서 필요한 데이터가 무엇인지 예측할 수 있음
    그리고 어떤 식으로 데이터를 받아야 화면에 노출시킬 수 있을지도 예측할 수 있음

  ------------------------------------------------------------------------------------------------



