자바스크립트의 스레드

자바스크립트는 싱글 스레드
스레드 === "일꾼"(ㄴ우리 코드를 동작하게 만들어주는)

a...(3초)
b...(2초)
c...(5초)
d...(10초)
e...(8초)
f...(30초)
main(5초) ----- 다 합치면 1분3초

싱글 스레드인 자바스크립트의 특징이 
현재 실행중인 태스크(기능)가 종료되어야만 다음 태스크를 실행하는 것

해당 특징 때문에 처리 시간이 지연되는 경우 비효율적

따라서 자바스크립트는 이벤트 루프를 활용하여 기존의 태스크가 종료되지 않아도
다음 태스크를 곧바로 실행하는 방식인 비동기를 도입하였다.

비동기를 도입함으로써
여러 태스크를 동시에 처리할 수 있으며, 정확히는 사람이 인지할 수 없을 정도의
찰나의 순간 순차적으로 실행
단점으로는 비동기로 실행되는 태스크의 실행 순서가 보장되지 않음


a...(3초)
b...(2초)
c...(5초)
d...(10초)
e...(8초)
f...(30초) --- 비동기

e의 함수에서는 d로 인해 매개변수가 수정이 되고
그 매개변수 수정이 된 것을 활용

따라서 d가 e보다 더 늦게 실행되므로(실행 순서가 보장되지 않으므로)
해당 매개변수는 수정되지 않은 채 e에 활용

=> 비동기 처리(ㄴ비동기 작업을 동기적으로 할 수 있게 하는 것)
ex) 상품정보(2초), 상품 목록(0.1초) ---> 상품 기능(2.1초)

-----------------------------------------------------------------------

동기 (순차적인 흐름) vs 비동기(지연, 블록킹 현상이 일어나는 것을 동시에 실행)
 
-----------------------------------------------------------------------

* 대표적인 비동기 함수

setTimeOut, setInterval, Promise

-----------------------------------------------------------------------

비동기 처리

비동기는 처리 시간이 각각 다르기 때문에 결과를 예상할 수 없음
따라서 결과에 따라 다음 함수(비동기, 동기)를 실행 시켜주시기 위하여 사용

(1) call back 
    콜백 함수로서 비동기 이후 실행해야 할 함수를 인자로 받고
    해당 비동기 함수가 실행되면 실행하는 방식

    * call back hell
        콜백 지옥이란, 콜백함수를 익명함수로 전달하는 과정에서 또 다시 콜백
        안에 콜백의 호출이 반복되어 들여쓰기 수준이 감당하기 힘들 정도로 깊어진
        상태

        주로 이벤트 처리나, 비동기 작업을 제어(비동기 처리)를 하기 위하여 사용
        되는데 이러한 프로그래밍은 가독성이 떨어지고 유지 보수를 어렵게 한다.

        ex)
        function 비동기(){
            setTimeOut(()=>{
                console.log("하나")
                setTimeOut(()=> {
                    setTimeOut(()=>{
                        setTimeOut(()=>{
                            ....
                        })
                    })
                })
            }, 1000)
        }

(2) promise  *** 많이 사용됌!
    ES6, promise는 new 연산자와 함께 호출하고 인자로 콜백을 받습니다.
    promise는 호출 시에 바로 실행되지만, 그 안에 resolve와 reject 둘 중하나가
    호출되기 전에 then이나 catch로 넘어가지 않습니다.

    then = 성공했을 때 (resolve의 결과값을 인자)
    catch = 실패했을 때 (reject의 결과값을 인자)

    예를 들면 서버에서 데이터 받기가 성공했다면 결과값은 resolve에 넘겨 then을
    호출하고 실패했다면 결과값(에러)를 reject에 넘겨 catch를 호출한다

    ex)

    const result = new Promise((resolve, reject) => {
        비동기 호출...
        비동기가 성공했을 때 resolve(res.data)
        비동기가 실패했을 때 reject(err)
    })

    result
    .then((res) => console.log(res)) // ㄴ여기서 res는 resolve
    .catch((err) => console.log(err)) // ㄴ여기서 err는 reject


(3) async await  /// ㄴㄴㄴ 이해 좀 안됌 ㅜ.ㅡ

    Promise로 비동기 처리를 한다고 하더라도 콜백 지옥이 연상되는 겻은 마찬가지
    따라서 ES2017에 추가된 async await의 경우는
    비동기 작업을 수행하고자 하는 함수 앞에 async를 표기 
    (자바스크립트 최신에는 async를 표기 하지 않아도 실행가능)

    async: 함수를 promise 형태로 반환
    await: 해당 함수(promise)가 실행될 때까지 promise가 resolve 될 때까지 대기
-----------------------------------------------------------------------

무료 JSON 데이터 테스트 https://jsonplaceholder.typicode.com/

-----------------------------------------------------------------------

ajax ? ㄴㄴ 걍 넘어가도 됌
Asynchronus Javascript and XML의 약자
본래 의미는 js를 활용한 비동기 통신, 클라이언트와 서버 간의 데이터를 주고 받는 기술

ex) 
좋아요 버튼을 누를 때마다 
DB(데이터 베이스)에 좋아요 숫자가 저장되어있고 해당 값이 1씩 추가될 것
(테이블에 데이터가 추가 되는 것 전체 데이터량이 1 늘어는 것)
그렇다면, 여러분들의 화면은 값이 과연 바뀌어 있을까요?

해결방법
(1) innerHTML 숫자 가져와서 +1 해주면 된다. 
    실패하면? = 데이터가 정확하지 않습니다. 

(2) 좋아요 버튼 누를 때마다 새로고침
    사용자 입장에서 본다면? 새로고침이 되는게 UI, UX에 올바른가

(3) ajax, axios, fetch와 같은 서버와의 비동기 통신을 위해 만들어진 라이브러리를
활용하여 성공과 실패 여부에 따라 백엔드에서 받아온 결과값을 가지고 (데이터 확신) 
DOM API 조작  ===> BEST 방법

-----------------------------------------------------------------------

*** axios / fetch

기존의 web에서는 이러한 비동기 요청을 위해 XML HTTP REQUEST 객체를 사용했어야함(ajax)
그러나 이러한 XHR은 요청의 상태나 변경에 따라 개발자의 의도와 함께 사용하기에는
적합하지 않습니다.
이를 보완하기 위하여 HTTP 요청에 최적화되고 상태 추상화도 잘되어있는 api들이
생겨나기 시작함
대표적으로 

axios, fetch

* fetch 
  ES6부터 JS 내장되어 있어 안정성이 뛰어남
  promise 기반으로 만들어졌으며 코드 또한 간편함

  ex) 
  option(method, header)

  fetch(url, option)
  .then()
  .catch()

---------------------------------------------------------------------

  fetch(url, {
    method : "POST"
    header : {
        "Accept" : "application/json",
        "Content-Type" : "application/json;charset=UTF-8"
    },
    body: JSON.stringfy({
        ...data
    })
  }).then()
    .catch()


---------------------------------------------------------------------

Axios 
    내장 x 설치 및 cdn으로 라이브러리를 가지고 와서 사용
    promise 기반
    크로스 브라우징에 신경을 썼기 때문에 거의 모든 브라우저 호환
    다양한 기능을 지원
    (timeout, interceptor ... )

    https://axios-http.com/kr/docs/intro

    ㄴ 꼭 들어가서 읽어보기!

    라이브러리를 설치해야하기 때문에 의존성이 높아진다. 

---------------------------------------------------------------------

API
    두 소프트웨어가 서로 통신할 수 있도록 하는 메커니즘의 한 종류

    ex) 기상청 소프트웨어는 일일 기상 데이터를 제공
        핸드폰의 소프트웨어는 해당 기상청 소프트웨어와 API를 통해 데이터를 교환하여
        핸드폰에 최신의 날짜 정보를 업데이트

REST API
    데이터를 이름으로 구분하여 해당 데이터의 상태를 주고받는 모든 것
    API에 이름을 주는 것

    ex) post method를 활용한 '/posts'
    단점: 유사한 데이터라고 하더라도 사용 목적에 따라 REST API를 지키기 
        위해서 다른 API 주소를 생성
        불필요한 데이터가 포함되는 경우가 많다

        ---> 보완 --> restAPI : graphQL (json 데이터를 주고 받는 것)

method
    개발자들 사이에 REST API를 위한 약속
    보통은 백엔드에서 해당 요청이 어떤 method인지 정해주니 해당 method에 맞게 
    req(요청)을 보내면 됌
    (api 문서, swagger을 통해 문서화되어 관리, test case)

    get ----> 얻다, 가져오다 (조회), data를 주소에 실어서 보낸다 //ㄴ body가 없음 얘만 나머지 밑에 애들은 다 있음

        주소에 데이터를 싣는 방법

        방법1) qs(params)
                "http://백엔드주소.com/?id=5&content="smile""

                (req.query.id = 5)
                (req.query.content = "smile")

        방법2) param
             "http://백엔드주소.com/22905?loc_good=rank

             ex)
                "/:prodId"
            
            (req.param.prodId = 22905)
            (req.query.loc_good = rank)



    post ----> 물품을 보내는 것 (생성), data를 보내야할 필요가 있음 
                                        (body에 data를 실어보낸다)
    put ---> 놓다 (수정), 모든 데이터를 수정(기존에 있던 데이터 대신해서 놓는다)
    patch --> 작은 조각들, 일부 데이터를 수정
    delete --> 삭제



    * 백엔드와 소통
    API, HTTP 활용

    request message

        header // 데이터의 형태, 보안, 설정 [title]
        body // 실제 데이터 json형태의 데이터 [content]


---------------------------------------------------------------------


location 객체

    자바스크립트의 window가 갖는 빌트인
    그러나 window 생략이 가능
    현재 인터넷 창의 URL(주소)을 나타내는 객체

    매서드(함수)
    * replace = 새로운 주소 이동, history가 남지 않습니다. (ex) 로그인 해주세요 라고 뜨는 창 (뒤로가기 남길 필요 없을 떄)
    * reload = 새로고침
    * assign = 새로운 주소 이동, history가 남는다

    속성 (ㄴ많이 사용하지는 않음)
    hash = #뒤에 붙은 값을 가지고 옴
    hostname = url의 도메인
    origin = 프로토콜 + url의 도메인 + 포트
    pathname = 원본주소 제외 경로 /posts
    port = 포트번호
    protocol = http:
    search = URL에 붙은 쿼리 값을 가지고 옵니다. ?postId=3
    href = 현재의 URL을 반환하고 있기 때문에 속성이 변화되면 해당 주소로 이동


history 객체

    history란 해당 url방문 기록을 조회하여 
    이전페이지 혹은 다음 페이지로 이동시킬 수 있는 객체

    ex)
    history.back() // ㄴ뒤로가기 버튼 눌러주는 애
    history.go(-1)
    history.forward() // 히스토리가 있어야 다음 페이지로 넘어감


---------------------------------------------------------------------