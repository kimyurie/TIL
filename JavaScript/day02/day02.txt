제어문

1. 조건문
특정한 조건이 주어지고 그 조건의 평가(비교연산자, 논리연산자) 에 따라 결과가 달라지는 것을 이야기 함

    (1) if ..else문
        if -> 만약에

        ex)
            ==> 만약에 조건식이 참이면
            if(조건식) {
                // 조건식이 참이면 실행할 문장
                console.log("참")

            ==> 아니면
            } else {
                // 조건식이 거짓이면 실행할 문장
                console.log("거짓")
            }


            ==> 만약에 조건식 1이 참이면
            if(조건식1){
                조건식 1이 참이면 실행할 문장

            ==> 아니면 조건식 2가 참이면
            } else if(조건식2){
                조건식 2가 참이면 실행할 문장
            
            ==> 아니면
            } else {
                조건식1과 조건식2가 모두 거짓이면 실행할 문장
            }

    (2) switch문

            switch(변수){
                case: 표현식1;
                    switch문의 변수가 표현식1과 일치하면 실행될 문장;
                case: 표현식2;
                    ...
                default:
                    기본값;
            }



2. 반복문
        주어진 조건식의 결과가 참(true)가 될 때까지 해당 블럭(구역, {...} )의 코드를 실행
        그 후 조건식을 다시 검사하여 여전히 참일 경우 다시 실행


    (1) for문

        for(초기화식; 조건식; 증감식) {
             조건식이 참인 경우 실행될 문장;
        }

        ex)
            for(let i=0; i<3; i++) {
                console.log(i+1)   // 1, 2, 3,
            }

        무한루프
        for(;;) {
            console.log("test") 
        }


    (2) while문
        
        while(조건식) {
            조건식이 true일 동안 실행할 문장
        }

        ex)

        let count = 0;
        while(count < 3){
            console.log(count); // 0, 1, 2
            count++;
        }

        무한루프
            while(true){} + 탈출문 ex. break;

            while(true){
                console.log(count);
                count++;
                if(count === 3) break;
            }


        do... while문
            조건과 상관 없이 코드를 무조건 한번 이상은 실행하고 무한루프

            let count = 0;

            do{
               console.log(count);
               count++;
            } while( count < 3 )

            // 3
            // 0,1,2

------------------------------------------------------------------------------------------------

    * Function (함수)

        자바스크립트 함수 지향 프로그래밍이다.

        함수지향프로그래밍이란?
            프로그래밍 패러다임의 한 종류

        프로그래밍 패러다임?
             개발자에게 프로그래머로서읙 관점을 갖게하고 결정하는 역할 => 개발 방법 중 하나

            명령형 프로그래밍 (어떻게 할 것인가가 중요, 구문과 연산을 중요)
                절차 지향 프로그래밍 : 순서를 중요 시, 컴퓨터 처리구조와 비슷한 구조 매우 속도가 빠름
                                      (ex. C, Cobol ... )

                객체 지향 프로그래밍 : 객체들의 집합으로 프로그래밍의 상호작용을 표현
                                      (ex. java, C++ ... )

            선언형 프로그래밍 (어떻게 할 것인가 보다는 무엇을 할 것인가가 중요)
                함수 지향 프로그래밍 : 순수함수를 조합하고 프로그래밍을 만드는 방식 (ex javascript)

        
        함수 지향 프로그래밍 관련 용어

            불변성 => 함수 밖에서 데이터 변형을 일으키지 않는다.
            클로저 => 부모 함수가 실행 종료되어도 참조할 수 있는 내부 함수는 기억된다
            순수함수 => 입력된 값에만 의존하고, 외부효과는 영향을 미치지 않는다.

            * 일급객체함수 => 입력 값(파라미터, 매개변수, 인자)이 있고 반환(return) 값이 있다

            유지관리가능성 => 외부 효과에 의존하지 않기 때문에 유지보수하기 쉽다.
            모듈화 => 모듈(한가지 기능 이상의 코드 집단) 분리하여 재사용 할 수 있다. 
            부수효과 => 함수 밖에서 함수 안의 반환 값에 영향을 끼치는 것( === 외부효과)
            참조투명성 => 동일한 값에는 항상 동일한 반환 값

            ...


        p.s 위의 언어를 알면 프로그래밍을 포기할 가능성이 높으므로
        ==> 자바스크립트는 함수를 기반으로 프로그래밍하는 함수 지향 프로그래밍이다.
            
-----------------------------------------------------------------------------------------------------

    함수
        함수의 기본은 어떠한 기능을 만든다에 의존하며 초점
        ===> 내가 만들고 싶은 기능

    
    함수의 선언
        function 함수명(파라미터1, 파라미터2, ...) {
            ... 연산 
            생략가능 return 결과값 ( 반환값 x void )
        };
        == 선언만 했을 뿐, 컴퓨터 기억만 시켰을 뿐 사용한 것은 아니다.


    함수의 실행
        함수명(파라미터1에 전달할 값, 파라미터2에 전달할 값, ...);



    * 프로그래밍 할 때는 무언가를 따라 친다는 개념보다는
    내가 어떠한 값을 넣고 어떠한 연산 과정을 거쳐서 어떤 결과 값을 만들어내고
    그 결과값을 어떻게 사용할 것이냐

    ** 모든 프로그래밍
        input -> operate -> output
        입력     연산      출력


                    모델(틀) -> DTO
        이메일  ->  저장(DB에 저장) -> 결과값(브라우저(view), 다른 함수,메서드)
        비밀번호
        
    
-----------------------------------------------------------------------------------------------------

    함수의 종류

    (1) 기명함수, 익명함수

        기명함수: 이름이 지어주었다.

        function hello() {
            console.log("hello") ---> hello
        }


        const world = function() {
            console.log("world") ---> x (익명함수)
        }

        hello();
        world();


        차이는 재사용성, 재사용이 될 가능성이 아예 전무하다고 확신하는 함수는
        익명함수로 처리해도 상관없음

        대표적인 예시 ( 콜백함수, 클로저, 즉시실행함수 )
        이 외의 경우에는 보통 기명함수


    (2) 재귀함수, 즉시실행함수

        재귀함수
            함수 안에서 같은 함수를 실행 (반복)
            (최단 경로 관련 알고리즘 문제 단골 출시)

            function f(n) {
                if( n <= 1) {
                    return 1;
                }
                return n + f(n-1)
            };


        즉시실행함수
            (function(){
                console.log("test")
            })();


            실행부 없이도 함수가 바로 실행 따라서 이름을 줄 필요가 없음(익명함수)


        화살표함수
            function 키워드 대신 화살표 ( => )를 사용하여 보다 간략한 방법으로 선언할 수 있는 방법
            ES6, ES7 최신버전의 문법

            ex)
                function a (파라미터1, 파라미터2) {
                }

                const a = (파라미터1, 파라미터2) => {
                }

            차이점
                this의 바인딩(결정) => 누가 나를 호출하였는가.
                자바스크립트의 this는 java와 같은 다른언어의 this와 바인딩 방식

                java와 같은 다른 언어의 this 정적 바인딩
                생성될 때 이미 this가 결정

                class A {
                    this.state = 값;
                }

                javascript의 this 바인딩은 방식이 다름
                동적 this 바인딩
                어떻게 호출되었는냐에 따라 this가 달라지는 것

                일반 함수는 호출 대상
                vs
                화살표 함수는 호출한 대상이 아닌
                항상 호출 대상의 상위 this를 가르킨다.

            쓰지 말아야할 때
                1. 객체의 메서드
                2. prototype
                3. 생성자 함수
                4. addEvnetListner의 콜백 함수


-----------------------------------------------------------------------------------------------------

    scope
        변수에 접근할 수 있는 범위
        변수를 찾기 위한 규칙

        자바스크립트에서 scope는 전역스코프, 지역스코프
        전역 스코프에는 전역(어떠한 곳)에서도 사용할 수 있는 값이 저장
        지역 스코프에는 해당 블록(특정한 구역. {...} )에서 사용할 수 있는 값이 저장


    지역 변수
        특정한 구역에서만 사용할 수 있는 변수
        단, 지역 변수가 전역변수 보다 우선(탐색)순위가 높다.
        특정 영역을 벗어나면 메모리에서 사라진다.

    전역 변수
        전체에서 사용할 수 있는 변수
        웹 페이지가 닫혀야만 메모리에서 사라진다.

    원리)

         특정 구역에서 사용 가능한 변수를 탐색
         그리고 해당 구역에 그 변수(사용하고자하는 변수)가 없으면

         스코프체인( 상위 스코프에 이동하여 해당 변수를 탐색 )
         가장 최상위 블럭에 전역 변수 스코프가 저장되어 있으므로

         어디에서든 사용이 가능


         let c = 7;
         {
            let b =5;

            {
                let a = 5;
                let c = 3; (x)
                console.log(a,b,c)  // 5 5 7    
                                    // 5 5 3
            }
         }

-----------------------------------------------------------------------------------------------------
















